#include<iostream>
#include<stdint.h>
#include<unordered_set>
#include<queue>
#include<tuple>
#include<time.h>
#include<set>
#include<unordered_map>
#include<fstream>
#define N 4
using namespace std;
int pattern1[N][N]= {{1,-1,-1,-1},
                     {5,6,-1,-1},
                     {9,10,-1,-1},
                     {13,-1,-1,0}};
int pattern2[N][N]= {{-1,-1,-1,-1},
                     {-1,-1,7,8},
                     {-1,-1,11,12},
                     {-1,14,15,0}};
int pattern3[N][N]= {{-1,2,3,4},
                     {-1,-1,-1,-1},
                     {-1,-1,-1,-1},
                     {-1,-1,-1,0}};

struct Node_pattern
{
    int x0,y0,cost;
    int Grid[N][N];
}start,dump,*process;
int i,j,ctr,x1,y1,x2,y2,x3,y3,x4,y4,x5,y5,x6,y6;
long long int Pattern_config_6;
int Pattern_config_3;
unordered_map<long long int,int> Pattern_check_6;
unordered_map<long long int,int>::const_iterator check_6;
unordered_map<int,int> Pattern_check_3;
unordered_map<int,int>::const_iterator check_3;
queue<Node_pattern> Patterns;
clock_t tStart,tEnd;
Pattern_config_6_calc(int &x0,int &y0)
{
    Pattern_config_6=0;
    Pattern_config_6+=x0;Pattern_config_6*=10;
    Pattern_config_6+=y0;Pattern_config_6*=10;
    Pattern_config_6+=x1;Pattern_config_6*=10;
    Pattern_config_6+=y1;Pattern_config_6*=10;
    Pattern_config_6+=x2;Pattern_config_6*=10;
    Pattern_config_6+=y2;Pattern_config_6*=10;
    Pattern_config_6+=x3;Pattern_config_6*=10;
    Pattern_config_6+=y3;Pattern_config_6*=10;
    Pattern_config_6+=x4;Pattern_config_6*=10;
    Pattern_config_6+=y4;Pattern_config_6*=10;
    Pattern_config_6+=x5;Pattern_config_6*=10;
    Pattern_config_6+=y5;Pattern_config_6*=10;
    Pattern_config_6+=x6;Pattern_config_6*=10;
    Pattern_config_6+=y6;
}
Pattern_config_3_calc(int &x0,int &y0)
{
    Pattern_config_3=0;
    Pattern_config_3+=x0;Pattern_config_3*=10;
    Pattern_config_3+=y0;Pattern_config_3*=10;
    Pattern_config_3+=x1;Pattern_config_3*=10;
    Pattern_config_3+=y1;Pattern_config_3*=10;
    Pattern_config_3+=x2;Pattern_config_3*=10;
    Pattern_config_3+=y2;Pattern_config_3*=10;
    Pattern_config_3+=x3;Pattern_config_3*=10;
    Pattern_config_3+=y3;
}
Neighbors_6_1(Node_pattern* temp_Node)
{
    //x0,y0
    if(temp_Node->x0+1<=N)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i][j+1];
                else if(i==temp_Node->y0-1&&j==temp_Node->x0)
                    dump.Grid[i][j]=temp_Node->Grid[i][j-1];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==1)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==5)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==6)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==9)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==10)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==13)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-1][temp_Node->x0]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->y0+1<=N)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i+1][j];
                else if(i==temp_Node->y0&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i-1][j];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==1)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==5)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==6)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==9)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==10)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==13)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0][temp_Node->x0-1]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->x0-1>0)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i][j-1];
                else if(i==temp_Node->y0-1&&j==temp_Node->x0-2)
                    dump.Grid[i][j]=temp_Node->Grid[i][j+1];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==1)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==5)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==6)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==9)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==10)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==13)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-1][temp_Node->x0-2]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->y0-1>0)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i-1][j];
                else if(i==temp_Node->y0-2&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i+1][j];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==1)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==5)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==6)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==9)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==10)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==13)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-2][temp_Node->x0-1]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
           if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
}
Neighbors_3(Node_pattern* temp_Node)
{
    //x0,y0
    if(temp_Node->x0+1<=N)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i][j+1];
                else if(i==temp_Node->y0-1&&j==temp_Node->x0)
                    dump.Grid[i][j]=temp_Node->Grid[i][j-1];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==2)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==3)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==4)
                {
                    x3=j+1;
                    y3=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-1][temp_Node->x0]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_3_calc(dump.x0,dump.y0);
        check_3=Pattern_check_3.find(Pattern_config_3);
        if(check_3==Pattern_check_3.end())
        {
            Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_3).second)
            {
                Pattern_check_3.erase(check_3);
                Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->y0+1<=N)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i+1][j];
                else if(i==temp_Node->y0&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i-1][j];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==2)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==3)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==4)
                {
                    x3=j+1;
                    y3=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0][temp_Node->x0-1]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_3_calc(dump.x0,dump.y0);
        check_3=Pattern_check_3.find(Pattern_config_3);
        if(check_3==Pattern_check_3.end())
        {
            Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_3).second)
            {
                Pattern_check_3.erase(check_3);
                Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->x0-1>0)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i][j-1];
                else if(i==temp_Node->y0-1&&j==temp_Node->x0-2)
                    dump.Grid[i][j]=temp_Node->Grid[i][j+1];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==2)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==3)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==4)
                {
                    x3=j+1;
                    y3=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-1][temp_Node->x0-2]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_3_calc(dump.x0,dump.y0);
        check_3=Pattern_check_3.find(Pattern_config_3);
        if(check_3==Pattern_check_3.end())
        {
            Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_3).second)
            {
                Pattern_check_3.erase(check_3);
                Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->y0-1>0)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i-1][j];
                else if(i==temp_Node->y0-2&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i+1][j];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==2)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==3)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==4)
                {
                    x3=j+1;
                    y3=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-2][temp_Node->x0-1]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_3_calc(dump.x0,dump.y0);
        check_3=Pattern_check_3.find(Pattern_config_3);
        if(check_3==Pattern_check_3.end())
        {
            Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_3).second)
            {
                Pattern_check_3.erase(check_3);
                Pattern_check_3.insert(make_pair(Pattern_config_3,dump.cost));
                Patterns.push(dump);
            }
        }
    }
}
Neighbors_6_2(Node_pattern* temp_Node)
{
    //x0,y0
    if(temp_Node->x0+1<=N)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i][j+1];
                else if(i==temp_Node->y0-1&&j==temp_Node->x0)
                    dump.Grid[i][j]=temp_Node->Grid[i][j-1];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==7)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==8)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==11)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==12)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==14)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==15)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-1][temp_Node->x0]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->y0+1<=N)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i+1][j];
                else if(i==temp_Node->y0&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i-1][j];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==7)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==8)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==11)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==12)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==14)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==15)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0][temp_Node->x0-1]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->x0-1>0)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i][j-1];
                else if(i==temp_Node->y0-1&&j==temp_Node->x0-2)
                    dump.Grid[i][j]=temp_Node->Grid[i][j+1];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==7)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==8)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==11)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==12)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==14)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==15)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-1][temp_Node->x0-2]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
            if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
    if(temp_Node->y0-1>0)
    {
        for(i=0;i<N;i++)
        {
            for(j=0;j<N;j++)
            {
                if(i==temp_Node->y0-1&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i-1][j];
                else if(i==temp_Node->y0-2&&j==temp_Node->x0-1)
                    dump.Grid[i][j]=temp_Node->Grid[i+1][j];
                else
                    dump.Grid[i][j]=temp_Node->Grid[i][j];
                if(dump.Grid[i][j]==0)
                {
                    dump.x0=j+1;
                    dump.y0=i+1;
                }
                if(dump.Grid[i][j]==7)
                {
                    x1=j+1;
                    y1=i+1;
                }
                if(dump.Grid[i][j]==8)
                {
                    x2=j+1;
                    y2=i+1;
                }
                if(dump.Grid[i][j]==11)
                {
                    x3=j+1;
                    y3=i+1;
                }
                if(dump.Grid[i][j]==12)
                {
                    x4=j+1;
                    y4=i+1;
                }
                if(dump.Grid[i][j]==14)
                {
                    x5=j+1;
                    y5=i+1;
                }
                if(dump.Grid[i][j]==15)
                {
                    x6=j+1;
                    y6=i+1;
                }
            }
        }
        if(temp_Node->Grid[temp_Node->y0-2][temp_Node->x0-1]==-1)
        {
            dump.cost=temp_Node->cost;
        }
        else
        {
            dump.cost=temp_Node->cost+1;
        }
        Pattern_config_6_calc(dump.x0,dump.y0);
        check_6=Pattern_check_6.find(Pattern_config_6);
        if(check_6==Pattern_check_6.end())
        {
            Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
            Patterns.push(dump);
        }
        else
        {
           if(dump.cost<(*check_6).second)
            {
                Pattern_check_6.erase(check_6);
                Pattern_check_6.insert(make_pair(Pattern_config_6,dump.cost));
                Patterns.push(dump);
            }
        }
    }
}
BFS_6_1()
{
    while(!Patterns.empty())
    {
        process=&Patterns.front();
        Neighbors_6_1(process);
        Patterns.pop();
    }
}
BFS_6_2()
{
    while(!Patterns.empty())
    {
        process=&Patterns.front();
        Neighbors_6_2(process);
        Patterns.pop();
    }
}
BFS_3()
{
    while(!Patterns.empty())
    {
        process=&Patterns.front();
        Neighbors_3(process);
        Patterns.pop();
    }
}
int main()
{
    ofstream o("Pattern_6_1.db",ios::binary);
    ofstream o1("Pattern_6_2.db",ios::binary);
    ofstream o2("Pattern_3.db",ios::binary);
    start.cost=0;
    for(i=0;i<N;i++)
    {
        for(j=0;j<N;j++)
        {
            start.Grid[i][j]=pattern1[i][j];
            if(pattern1[i][j]==0)
            {
                start.x0=j+1;
                start.y0=i+1;
            }
            if(pattern1[i][j]==1)
            {
                x1=j+1;
                y1=i+1;
            }
            if(pattern1[i][j]==5)
            {
                x2=j+1;
                y2=i+1;
            }
            if(pattern1[i][j]==6)
            {
                x3=j+1;
                y3=i+1;
            }
            if(pattern1[i][j]==9)
            {
                x4=j+1;
                y4=i+1;
            }
            if(pattern1[i][j]==10)
            {
                x5=j+1;
                y5=i+1;
            }
            if(pattern1[i][j]==13)
            {
                x6=j+1;
                y6=i+1;
            }
        }
    }
    Pattern_config_6_calc(start.x0,start.y0);
    Pattern_check_6.insert(make_pair(Pattern_config_6,0));
    Patterns.push(start);
    BFS_6_1();
    string trim;
    unordered_map<long long int,int> trimmed;
    unordered_map<long long int,int>::const_iterator check_trim;
    long long int trimmed_int;
    int cost;
    for(i:Pattern_check_6)
    {
        trim=to_string(i.first);
        trim.erase(0,2);
        trimmed_int=stoll(trim);
        check_trim=trimmed.find(trimmed_int);
        if(check_trim==trimmed.end())
            trimmed.insert(make_pair(trimmed_int,i.second));
        else
        {
            if(i.second<(*check_trim).second)
            {
                trimmed.erase(check_trim);
                trimmed.insert(make_pair(trimmed_int,i.second));
            }
        }
    }
    Pattern_check_6.clear();
    for(i:trimmed)
    {
        trimmed_int=i.first;
        cost=i.second;
        o.write((char*)&trimmed_int,sizeof(trimmed_int));
        o.write((char*)&cost,sizeof(cost));
    }
    trimmed.clear();
    o.close();
    start.cost=0;
    for(i=0;i<N;i++)
    {
        for(j=0;j<N;j++)
        {
            start.Grid[i][j]=pattern2[i][j];
            if(pattern2[i][j]==0)
            {
                start.x0=j+1;
                start.y0=i+1;
            }
            if(pattern2[i][j]==7)
            {
                x1=j+1;
                y1=i+1;
            }
            if(pattern2[i][j]==8)
            {
                x2=j+1;
                y2=i+1;
            }
            if(pattern2[i][j]==11)
            {
                x3=j+1;
                y3=i+1;
            }
            if(pattern2[i][j]==12)
            {
                x4=j+1;
                y4=i+1;
            }
            if(pattern2[i][j]==14)
            {
                x5=j+1;
                y5=i+1;
            }
            if(pattern2[i][j]==15)
            {
                x6=j+1;
                y6=i+1;
            }
        }
    }
    Pattern_config_6_calc(start.x0,start.y0);
    Pattern_check_6.insert(make_pair(Pattern_config_6,0));
    Patterns.push(start);
    BFS_6_2();
    for(i:Pattern_check_6)
    {
        trim=to_string(i.first);
        trim.erase(0,2);
        trimmed_int=stoll(trim);
        check_trim=trimmed.find(trimmed_int);
        if(check_trim==trimmed.end())
            trimmed.insert(make_pair(trimmed_int,i.second));
        else
        {
            if(i.second<(*check_trim).second)
            {
                trimmed.erase(check_trim);
                trimmed.insert(make_pair(trimmed_int,i.second));
            }
        }
    }
    Pattern_check_6.clear();
    for(i:trimmed)
    {
        trimmed_int=i.first;
        cost=i.second;
        o1.write((char*)&trimmed_int,sizeof(trimmed_int));
        o1.write((char*)&cost,sizeof(cost));
    }
    trimmed.clear();
    o1.close();
    start.cost=0;
    for(i=0;i<N;i++)
    {
        for(j=0;j<N;j++)
        {
            start.Grid[i][j]=pattern3[i][j];
            if(pattern3[i][j]==0)
            {
                start.x0=j+1;
                start.y0=i+1;
            }
            if(pattern3[i][j]==2)
            {
                x1=j+1;
                y1=i+1;
            }
            if(pattern3[i][j]==3)
            {
                x2=j+1;
                y2=i+1;
            }
            if(pattern3[i][j]==4)
            {
                x3=j+1;
                y3=i+1;
            }
        }
    }
    Pattern_config_3_calc(start.x0,start.y0);
    Pattern_check_3.insert(make_pair(Pattern_config_3,0));
    Patterns.push(start);
    BFS_3();
    unordered_map<int,int> trimmed_3;
    unordered_map<int,int>::const_iterator check_trim_3;
    int trimmed_int_3;
    for(i:Pattern_check_3)
    {
        trim=to_string(i.first);
        trim.erase(0,2);
        trimmed_int_3=stoll(trim);
        check_trim_3=trimmed_3.find(trimmed_int_3);
        if(check_trim_3==trimmed_3.end())
            trimmed_3.insert(make_pair(trimmed_int_3,i.second));
        else
        {
            if(i.second<(*check_trim_3).second)
            {
                trimmed_3.erase(check_trim_3);
                trimmed_3.insert(make_pair(trimmed_int_3,i.second));
            }
        }
    }
    Pattern_check_3.clear();
    for(i:trimmed_3)
    {
        trimmed_int_3=i.first;
        cost=i.second;
        o2.write((char*)&trimmed_int_3,sizeof(trimmed_int_3));
        o2.write((char*)&cost,sizeof(cost));
    }
    trimmed_3.clear();
    o2.close();
}
